PHP DAEMON - CZĘŚĆ IV
--------------------------------------------------------------------------

W pierwszym artykule (http://inside-the-source-code.blogspot.com/2014/08/php-deamons-czesc-i.html) 
z cyklu "PHP Daemons" przedstawione zostało rozwiązanie oparte o mechanizm forkowania. Następnie, 
z uwagi na powstawanie "procesów zombie", wprowadzone zostało rozwiązanie (http://inside-the-source-code.blogspot.com/2014/09/php-daemon-czesc-ii.html) 
pozwalające wyeliminować ten problem. Jednak dalsze testy i eksploatacja tego daemona wykazały
jego kolejną słabość - przy jednoczesnej obsłudze wielu połączeń, które kończą swoje działanie
w tym samym czasie (ticku procesora) licznik aktywnych połączeń pomniejszany jest o jeden zamiast
rzeczywistą liczbę połączeń, które zakończyły działanie w tym momencie. W efekcie, bardzo szybko
może wystąpić przekroczenie max liczby połączeń (nie będziemy przyjmowali nowych połączeń), chociaż
tak naprawdę będzie uruchomiony tylko jeden proces. Wspomniana sytuacja wynika z tego, że obsługa
sygnałów (http://en.wikipedia.org/wiki/Unix_signal) w systemach Unix została zaprojektowana w taki sposób, 
aby w danym momencie czasu, z uwagi na potencjalne wyścigi, przyjąć tylko jeden sygnał danego typu, np. SIGUSR2.
Dlatego też konieczne jest zastosowanie innego mechanizmu do kontroli liczby aktywnych połączeń.

Informacja o rozpoczęciu obsługi nowego połączenia bądź zakończeniu jego działania powinna zostać
przekazana do procesu głównego (ang. parent) celem kontroli przekraczania max liczby połączeń.
Zatem wymagana będzie komunikacja między procesami (http://en.wikipedia.org/wiki/Inter-process_communication)
(ang. IPC - inter-process communication). W systemach Unixowych dostępne są następujące mechanizmy IPC:

* sygnały (ang. signals)
* potoki nienazwane (ang. pipes)
* potoki nazwane / kolejki FIFO (ang. First In First Out) 
* pliki i blokady (ang. file locks)
* kolejki wiadomości (ang. message queues)
* semafory (ang. semaphores)
* pamięc współdzieloną (ang. shared memory)
* gniazdka (ang. sockets)       

Wymienione powyżej mechanizmy obsłużone mogą być również za pomocą PHP. Przykładowo, pipes reazliowane 
są za pomocą funkcji popen() / proc_open() / pclose(), kolejki FIFO - posix_mkfifo(), locks - flock() itd. 
Poszczególne rozwiązania różnią się między sobą i nie każde nadaje się do obsługi danych funkcjonalności.
W naszym przypadku, do implementacji globalnego licznika aktywnych połączeń, najlepszym mechanizmem będzie
pamięć współdzielona (http://en.wikipedia.org/wiki/Shared_memory) między procesami dzieci i procesem głównym.

<code data-gist-id="41e9a54168063c93a9e5" data-gist-line="98, 102-107" data-gist-highlight-line="104" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

Shared memory została wybrana, ponieważ wszystkie procesy będą działały w obrębie jednej lokalnej maszyny, dodatkowo 
zmiany licznika aktywnych połączeń powinny być bardzo szybkie stąd też oparcie tego mechanizmu na plikach czy gniazdkach 
nie będzie najlepszym wyborem. W pamięci współdzielonej przechowywana będzie liczba procesów 
utworzonych do obsługi poszczególnych klientów - w momencie forkowania (przez proces główny) licznik będzie podbijany, 
natomiast kończąc swoje działanie wartość ta będzie pomniejszana (przez proces dziecka). 

<code data-gist-id="41e9a54168063c93a9e5" data-gist-line="493, 503-540, 577-591" data-gist-highlight-line="512, 585" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

Szybkość pamięci współdzielonej wynika w głównej mierze z tego, oprócz faktu że realizowana jest w bezpośrednio w pamięci, iż do jej 
obsługi nie jest wymagana komunikacja z kernelem, jak to ma miejsce chociażby w przypadku potoków (ang. pipes). Jednak rozwiązanie to
nie jest idealne - jak sugeruje sama nazwa mechanizmu, dostęp do współdzielonego obszaru pamięci będzie miało wiele procesów a więc tym
samym czasie może probować wprowadzać zmiany naszego licznika. Aby zapobiec tym wyścigom (ang. race conditions) konieczne
będzie dodanie synronizacji. Wśród dostępnych mechanizmów komunikacji między procesami dostępny jest taki mechanizm - semafory
(http://en.wikipedia.org/wiki/Semaphore_%28programming%29). Zatem schemat działania będzie następujący:

* utworzenie nowego procesu do obsługi połaczenia
* założenie semafora - zablokowanie dostępu do wprowdzania zmian licznika     
* zwiększenie licznika
* zwolnienie semafora - usunięcie blokady dostępu do wprowadzania zmian licznika
* obsługa połączenia
* założenie semafora, zmniejszenie licznika, zwolenienie semafora
* zakończenie działania procesu dziecka

<code data-gist-id="41e9a54168063c93a9e5" data-gist-line="107, 112-128, 139, 145-164" data-gist-highlight-line="116, 124, 149, 160" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

Warto zwrócić uwagę jeszcze na jedną istotną kwestię. Otóż współdzielonej pamięci nie obejmuje mechanizm
"reference counter" wykorzystywany przez PHPowy GC (ang. garbage collector). Oznacza to, iż kończąc działanie
daemona nie zostanie zwolniona pamięć zarezerwowana dla segmentu shared memory. W związku z tym konieczne
jest ręczne zwolnienie tej pamięci, w przeciwnym razie będzie ona zajęta do czasu restartu maszyny.

<code data-gist-id="41e9a54168063c93a9e5" data-gist-line="189, 193-201, 395, 401-432" data-gist-highlight-line="197, 414" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

Wprowadzenie licznika opartego o współdzieloną pamięć nieco zwolni szybkość działania naszego daemona z uwagi na konieczność
synchronizacji dostępu opartej o semafory. Niemniej, dzięki temu, nasz daemon będzie odporny na problemy opisane powyżej
(nieprawidłowe zmniejszanie licznika w przypadku równoczesnego kończenia pracy przez wiele połączeń) a oparta na tym liczniku
kontrola max liczby połączeń zabezpieczy nas przed zbytnim obciążeniem maszyny. Jeśli uzyskana w ten sposób wydajność
daemona będzie za mała, będziemy mogli skalować się dokładając kolejne node'y do naszego clustra. Ciekawą alternatywą dla
zaproponowanego tutaj licznika aktywnych połączeń opartego o shared memory może być APC (ang. Alternative PHP Cache).
Jednak, przynajmniej według mnie, bezpośrednia kontrola nad tym co dokładnie dzieje się w aplikacji jest lepszym rozwiązaniem
a koniec końców APC i tak działa w oparciu o shared memory bądź mmap (w zależności od konfiguracji). Inne godne rozważenia alernatywy
to rozwiązania oparte o /dev/shm, php://memory czy też tmpfs. Zachęcam do eksperymentów, korzystania z proponowanego przeze
mnie rozwiązania no i zgłaszania własnych uwag i wniosków.

Kompletny kod znajdziecie tutaj (https://gist.github.com/thejoyboy/41e9a54168063c93a9e5). 

Przydatne linki:

* http://www.linux-tutorial.info/modules.php?name=MContent&pageid=289
* http://www.makelinux.net/books/lkd2/ch03lev1sec1
* http://linuxgazette.net/133/saha.html
* http://www.cis.temple.edu/~ingargio/cis307/readings/signals.html
* http://cs-pub.bu.edu/fac/richwest/cs591_w1/notes/wk3_pt2.PDF
* http://andrey.hristov.com/projects/php_stuff/pres/writing_parallel_apps_with_PHP.pdf
* http://linux.die.net/man/5/ipc
* http://beej.us/guide/bgipc/output/html/singlepage/bgipc.html
* http://tldp.org/LDP/lpg/node7.html
* http://www.amazon.com/exec/obidos/ISBN=0130810819/thevanishedgalle/
* http://stackoverflow.com/questions/404604/comparing-unix-linux-ipc
* http://linux.omnipotent.net/article.php?article_id=12504
* http://www.workingsoftware.com.au/page/Something_Like_Threading
* http://www.tuxradar.com/practicalphp/16/1/9
* http://www.cs.cf.ac.uk/Dave/C/node27.html
* http://www.kohala.com/start/unpv22e/unpv22e.chap12.pdf
* https://stereochro.me/assets/uploads/notes/dcom3/shmem.pdf
* http://en.wikipedia.org/wiki/Memory-mapped_file
* http://www.onlamp.com/pub/a/php/2004/05/13/shared_memory.html
* http://www.ibm.com/developerworks/library/os-php-shared-memory/
* http://php.find-info.ru/php/016/ch10lev1sec7.html
* http://www.re-cycledair.com/php-dark-arts-shared-memory-segments-ipc
* http://www.re-cycledair.com/php-dark-arts-semaphores
* http://stackoverflow.com/questions/8631875/what-does-the-shmop-php-extension-do
* http://werxltd.com/wp/2010/08/23/process-forking-with-php/
* http://sysmagazine.com/posts/193270/
* http://pubs.opengroup.org/onlinepubs/007908799/xsh/mmap.html
* http://msdn.microsoft.com/en-us/library/ms810613.aspx
* http://www.devshed.com/c/a/BrainDump/Using-mmap-for-Advanced-File-IO/
* https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt
* http://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html
* http://stephane.lesimple.fr/blog/2006-11-03/dev-shm-is-better-than-tmp.html
* http://php.net/manual/en/function.stream-socket-pair.php
* http://php.net/manual/en/book.apc.php
* http://git.php.net/?p=pecl/caching/apc.git;a=blob;f=TECHNOTES.txt
* https://github.com/lifo101/php-ipc
* https://github.com/clue-legacy/Worker
* https://github.com/klaussilveira/SimpleSHM
* https://github.com/jamm/Memory
* https://github.com/nanderoo/php-memory-demo

TAGI: PHP, daemons, sockets, multitasking, signals, IPC, inter-process communication, shared memory, pipe, fifo, semaphore


