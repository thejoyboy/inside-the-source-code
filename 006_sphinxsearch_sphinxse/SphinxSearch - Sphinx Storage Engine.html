<p align="justify">Silniki wyszukiwania pełnotekstowego, a <b>SphinxSearch</b> z pewnością może do takich się zaliczyć, stworzone zostały z myślą sprawnego i wydajnego wyszukiwania tekstu, niekoniecznie przechowując go jednocześnie. Zatem, typowy scenariusz aplikacji korzystającej z takiego silnika wygląda następująco:<br />

<ol>
<li>wyszukiwanie dokumentów za pomocą silnika wyszukiwania (np. <i>SphinxSearch</i>)</li>
<li>pobranie właściwej treści dokumentów (z bazy danych bądź innego źródła ) dla wyników znalezionych w poprzednim kroku</li>
</ol>
</p>

<p align="justify">Inny, często spotykany przypadek, jest taki, iż istniejącą aplikację chcemy rozszerzyć o możliwość wyszukiwania - w tym przypadku konieczne będzie wprowadzenie szeregu zmian, sposób postępowania będzie podobny do tego opisanego powyżej: wyszukiwanie, np. korzystając z <i>API</i>, pobranie wymaganych informacji dla znalezionych wyników. Tutaj z pomocą przychodzi rozwiązanie znane jako <i>SphinxSE</i>.</p>

<p align="justify"><b>SphinxSE</b> (ang. <i>Sphinx Storage Engine</i>) to jeden z dostępnych silników przechowywania (ang. <i>storage engine</i>) takich jak np. <i>InnoDb</i> czy też <i>MyISAM</i>. Nie przechowuje on jednak danych sam w sobie a jest jedynie wbudowanym klientem umożliwiającym komunikację ze Sphinxem, wykonywanie zapytań oraz pobieranie wyników. Zaletą tego rozwiązania jest to, że przedstawione powyżej dwa kroki można zredukować do jednego - w jednym kroku wyszukujemy dokumenty oraz pobieramy właściwą treść dokumentu dla znalezionych wyników. Co więcej, także w przypadku rozbudowania istniejącej aplikacji o wyszukiwanie, koszt zmian nie będzie duży - wystarczy jedynie dodać do istniejącego zapytania <i>SQL</i> warunek zgodny ze składnią wyszukiwania <i>SphinxSE</i> i złączyć wyniki ze Sphinxa z rezultatami otrzymanymi przez pierwotne zapytanie do bazy.</p>

<p align="justify">Rolę pośrednika pomiędzy search daemonem Sphinxa (<i>searchd</i>) a bazą danych (<b>MySQL</b>, <b>MariaDb</b>) pełni pomocnicza tabela o strukturze:
<br /><br />      

<code data-gist-id="a876323e3e132f8fecd0" data-gist-line="1-12" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

</p>

<p>Nazwa tabeli oczywiście jest dowolna, ale konieczne jest aby pierwsze trzy kolumny były następujących typów:<br />

<ul>
<li>pierwsza - <i>INTEGER UNSIGNED</i> lub <i>BIGINT</i>: identyfikator dokumentu</li>
<li>druga - <i>INTEGER</i> bądź <i>BIGINT</i>: waga (<i>score</i>) znalezionego dokumentu</li>
<li>trzecia - <i>VARCHAR</i> lub <i>TEXT</i>: zapytanie oraz powinna być indeksowana</li>
</ul>
</p>

<p align="justify">Pozostałe, dodatkowe kolumny mogą być typów <i>INTEGER</i>, <i>TIMESTAMP</i>, <i>BIGINT</i>, <i>VARCHAR</i> lub <i>FLOAT</i> - będą reprezentowały atrybuty odpowiadające nazwom kolumn (stąd wymagana zgodność typów kolumn dla odpowiadających im atrybutom). Dodatkowo istnieją specjalne kolumny <b>_sph_groupby</b>, <b>_sph_count</b>, <b>_sph_distinct</b> zawierające liczniki dla klauzul <b><i>@groupby</i></b>, <b><i>@count</i></b> oraz <b><i>@distinct</i></b>. Ponadto, dla tabeli-pośrednika trzeba ustawić <b>ENGINE=SPHINX</b>.</p> 

<p align="justify">Po wysłaniu zapytania i otrzymaniu wyników ze <i>Sphinxa</i>, pomocnicza tabela będzie zawierała znalezione wyniki: identyfikator dokumentu - kolumna id, score wyniku - <i>weight</i> oraz wartości atrybutów w kolejnych kolumnach o nazwach odpowiadającym nazwom atrybutów. Złączając otrzymane wyniki (<i>sphinx_results</i>) z tabelą (lub tabelami) przechowującymi szczegółowe informacje o dokumentach rozwiążemy problem opisany na początku artykułu.<br />

<br />Przykład:<br /><br />

<code data-gist-id="a876323e3e132f8fecd0" data-gist-line="15-27" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

</p>

<p align="justify">Ze złączenia wyników ze Sphinxa z innymi tabelami będziemy mogli zrezygnować jeśli w indeksie będziemy przechowywali (w postaci atrybutów) także wartości, w których wyszukujemy (np. title, content itd.). W tym celu konieczna jest zmiana konfiguracji indeksu:<br /><br />

<code data-gist-id="b4794ae38b2ad7ced9d2" data-gist-line="1-5,50-64" data-gist-highlight-line="60-62" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

W tym przypadku nasze zapytanie będzie wyglądało następująco:<br /><br />

<code data-gist-id="a876323e3e132f8fecd0" data-gist-line="30-38" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

</p>

<p align="justify">Składania zapytań <i>SphinxSE</i> została szczegółowo opisana w <a href="http://sphinxsearch.com/docs/current.html#sphinxse-using" target="_blank">dokumentacji</a>, przedstawię jedynie typowe, godne uwagi przypadki:<br />

<ul><li><b>filtrowanie</b> - w pierwszej kolejności wykonywane jest wyszukiwanie dla podanej frazy a następnie uzyskane wyniki są filtrowane po wybranym atrybucie, dlatego warto rozważyć (ze względów optymalizacyjnych) czy nie korzystniej będzie zaindeksować i przeszukiwać pole zawierające atrybut</li></ul>
<br />

<code data-gist-id="a876323e3e132f8fecd0" data-gist-line="41-53" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<ul><li><b>grupowanie</b> - istnieje możliwość grupowania bezpośrednio po atrybucie (<b><i>groupby=attr:attr_name</i></b>) bądź korzystając z predefiniowanego ziarna czasowego (jeśli atrybut typu timestamp), np. ziarno dzienne (<b><i>groupby=day:attr_name</i></b>), tygodniowe (<b><i>groupby=week:attr_name</i></b>) itd. Dodatkowo <i>_sph_count</i> będzie zawierał liczbę wyników w danej grupie</li></ul>
<br />

<code data-gist-id="a876323e3e132f8fecd0" data-gist-line="56-63" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<ul><li><b>escape'owanie wartości specjalnych w zapytaniach</b> - wartości specjalne takie jak np. <i>;</i> bądź <i>=</i> czy też <i>,</i> (przecinek) escape'ujemy za pomocą trzech <i>/</i> (slash). Dodatkowo jeśli w zapytaniu pojawia się " (cudzysłów) a treść całego zapytania <i>SphinxSE</i> (query) zawieramy również pomiędzy "", w takim przypadku cudzysłów w szukanej frazie należy poprzedzić siedmioma znakami slash, ponieważ escape'ujemy wyrażenie /" (trzy / dla slasha oraz kolejne trzy dla "). Przykład - szukamy frazy <i>"test" 'test' test% @;,=</i></li></ul>
<br />

<code data-gist-id="a876323e3e132f8fecd0" data-gist-line="66-73" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

</p>

<p align="justify">Podsumowując, pomimo tego iż <i>SphinxSE</i> nie oferuje pełnych możliwości wyszukiwania za pomocą <i>SphinxSearch</i> oraz wymaga znajomości specyficznej 
składni zapytań, warto rozważyć wykorzystanie tego rozwiązania w naszej aplikacji. Możemy w prosty i bardzo wydajny sposób, a przy tym nie wymagający dużych nakładów pracy, umożliwić zaawansowane wyszukiwanie w naszym serwisie.</p>

<p>Przydatne linki:
<ul>
<li><a href="http://sphinxsearch.com/docs/current.html#sphinxse" target="_blank">http://sphinxsearch.com/docs/current.html#sphinxse</a></li>
<li><a href="http://www.slideshare.net/bytebot/mariadb-with-sphinxse" target="_blank">http://www.slideshare.net/bytebot/mariadb-with-sphinxse</a></li>
<li><a href="https://mariadb.com/kb/en/sphinxse/" target="_blank">https://mariadb.com/kb/en/sphinxse/</a></li>
<li><a href="http://www.pythian.com/blog/using-the-sphinx-search-engine-with-mysql/" target="_blank">http://www.pythian.com/blog/using-the-sphinx-search-engine-with-mysql/</a></li>
<li><a href="http://www.mysqlperformanceblog.com/2013/01/15/sphinx-search-performance-optimization-attribute-based-filtering/" target="_blank">http://www.mysqlperformanceblog.com/2013/01/15/sphinx-search-performance-optimization-attribute-based-filtering/</a></li>
</ul>
</p>
