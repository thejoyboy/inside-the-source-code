<p align="justify">Wiele z istniejących aplikacji zostało zbudowanych z wykorzystaniem baz danych. Cechą charakterystyczną tego rozwiązania jest to, iż przechowywane dane zgodne są z ustalonym schematem (<i>mappingiem</i>) tj. zbiorem nazw i typów danych atrybutów, np. <i>id</i> - <i>long</i>, <i>name</i> - <i>string</i> itd. Podobnie przedstawia się sytuacja w przypadku, gdy bazę danych zastąpimy rozwiązaniem znanym jako <i><b>SphinxSearch</b></i>. Tutaj również mamy jasno zdefiniowany zbiór kluczy (atrybutów) i odpowiadającym im wartości (wraz z typami danych). Dla większości przypadków taki sposób ogranizacji danych jest wystarczający, ale zdarzają się sytuacje gdy dla danego klucza będziemy chcieli przechowywać (oraz wyszukiwać) dane o różnej strukturze w zależności od kontekstu. Przykładowo, nasza aplikacja to typowy sklep internetowy zawierający zbiór produktów. Dla większości z nich można zdefiniować wspólny zbiór cech (np. cena, nazwa, opis), ale w zależności od kategorii potrzebne będą indywidualne cechy, np. dla książek - liczba stron, laptopów - liczba zainstalowanej pamięci RAM, pojemność dysku twardego itd. Jednocześnie chcemy przechowywać produkty różnych kategorii w jednym zbiorze danych. Rozwiązaniem tego problemu jest przechowywanie zbioru atrybutów w formacie <b><i>JSON</i></b>.</p>

<p align="justify">W tym celu konieczne jest wprowadzenie zmian w konfiguracji, tak aby atrybuty w formacie JSON były indeksowane oraz wyszukiwanie. Definiujemy zatem jeden z atrybutów: <i><b>sql_attr_json</b></i>, <i><b>xmlpipe_attr_json</b></i> bądź <i><b>rt_attr_json</b></i>.</p>

<code data-gist-id="b4794ae38b2ad7ced9d2" data-gist-line="1-5,65-80" data-gist-highlight-line="77" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<p align="justify">Oprócz wspomnianej powyżej definicji atrybutów typu <i>sql_attr_json</i>, warto również zwrócić uwagę na następujące parametry konfiguracji:<br />
<ul>
<li><i><b>on_json_attr_error</b></i> - obsługa błędów formatu JSON: <i>ignore_attr</i> (domyślna, błędy zostaną wyświetlone, indeksowanie będzie kontynuowane), <i>fail_index</i> (indeksowanie zostanie przerwane w momencie wystąpienia błędu)</li>
<li><i><b>json_autoconv_numbers</b></i> - wykrywanie i konwersja stringów do formatu liczb: <i>0</i> (domyślne, konwersja nie jest wykonywana), <i>1</i> (konwersja włączona); przykładowo jeśli <i>json_autoconv_numbers = 1</i>, <i>"obj": { "id" : 123 }</i> będzie reprezentowany jako <i>obj.id = 123</i>, w przeciwnym razie <i>obj.id = "123"</i></li>
<li><i><b>json_autoconv_keynames</b></i> - sposób konwersji nazw kluczy wewnątrz atrybutu typu JSON: <i>lowercase</i> (zamiana na małe litery) bądź brak wartości (domyślne, konwersja wyłączona)</li>
</ul>
</p>

<p>Przykład: indeksujemy dokumenty JSON (pole <i>json_content</i>) postaci<br /><br />

<code data-gist-id="ce2f63a3a24936b30ba0" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>
</p>

<p>oraz wyszukujemy<br /><br />

<code data-gist-id="e2261f94a27bdfff4a8e" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

</p>

<p align="justify">Więcej zapytań znajdziecie w linkach zamieszczonych na końcu wpisu. Chciałbym jednak zwrócić uwagę na następujące problemy:<br />

<ul>
<li>aktualna, stabilna wesja nie posiada jeszcze pełnej obsługi formatu JSON, pełna obłsuga dostępna od wersji <i>2.2.3-beta</i></li>
<li><b>SphinxSE</b> nie zawiera obsługi JSON - biblioteka ha_sphinx dla <i>MariaDB 5.2</i> / <i>5.3</i> korzysta ze SphinxSearch w wersji <i>0.9.9</i>, <i>MariaDB 5.5</i> - <i>2.0.4</i></li>
<li>nieprawidłowa obsługa (w niektórych przypadkach) zapytań <i>IN()</i> w aktualnej, stabilnej wersji, błąd poprawiony w wersji <i>2.2.3-beta</i></li>
</ul>
</p>

<p align="justify">Pomimo tego, iż pełna obsługa atrybutów typu <i>JSON</i> nie jest jeszcze dostępna (w wersji stabilnej), dzięki temu rozwiązaniu otrzymujemy nowe możliwości, które będziemy mogli wykorzystać w naszej aplikacji. Zachęcam Was do wypróbowania tej funkcjonalności w Waszych aplikacjach, pozostaje nam czekać na stabilną wersję <i>2.2.3</i>.</p>

<p>Przydatne linki:<br />

<ul>
<li><a href="http://sphinxsearch.com/blog/2013/02/07/sphinx-2-1-json-attributes/" target="_blank">http://sphinxsearch.com/blog/2013/02/07/sphinx-2-1-json-attributes/</a></li>
<li><a href="http://sphinxsearch.com/blog/2013/08/08/full-json-support-in-trunk/" target="_blank">http://sphinxsearch.com/blog/2013/08/08/full-json-support-in-trunk/</a></li>
<li><a href="http://sphinxsearch.com/docs/current.html#conf-sql-attr-json" target="_blank">http://sphinxsearch.com/docs/current.html#conf-sql-attr-json</a></li>
<li><a href="http://sphinxsearch.com/forum/view.html?id=10990" target="_blank">http://sphinxsearch.com/forum/view.html?id=10990</a></li>
<li><a href="http://sphinxsearch.com/bugs/view.php?id=1727" target="_blank">http://sphinxsearch.com/bugs/view.php?id=1727</a></li>
<li><a href="http://sphinxsearch.com/bugs/view.php?id=1870" target="_blank">http://sphinxsearch.com/bugs/view.php?id=1870</a></li>
<li><a href="http://sphinxsearch.com/bugs/view.php?id=1946" target="_blank">http://sphinxsearch.com/bugs/view.php?id=1946</a></li>
</ul>
</p>

