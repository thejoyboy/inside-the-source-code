<p align="justify">Bardzo często, w zależności od rozwiązywanego problemu, stosuje się powszechnie znane rozwiązania, np. strona web - <i>PHP</i>, rozwiązania klient-serwer bądź <i>daemony</i> - język C itd. Zaletą takiego podejścia jest fakt, iż rozwiązania te zostały zoptymalizowane i wielokrotnie przetestowane <i>w boju</i>. Zdarza się jednak tak, że oprogramowanie wytwarzane w naszej firmie skoncentrowane jest wokół jednej (bądź grupy) technologii, np. <i>PHP</i> / <i>LAMP</i>. Poznanie i wdrożenie nowej technologii może być zbyt kosztowne czy też czasochłonne. W takiej sytuacji adaptuje się istniejące rozwiązania do naszych potrzeb. Podobnie będzie w naszym przypadku - głównym "bohaterem" tego artykułu będzie <b>daemon</b> zaimplementowany w <b>PHP</b>.</p>

<p align="justify">Głównym wyzwaniem przed jakim staje taki <i>daemon</i> jest obsługa wielu równoległych połączeń. Niestety, język PHP nie został zaprojektowany z myślą o obsłudze wielu wątkow. Zatem, pozostaje nam skorzystać z tradycyjnej obsługi wielu zadań (<i>ang. multitasking</i>) znanej z systemów <i>Unix</i> - powielanie procesów za pomocą <b>forka</b> (<i>ang. forking</i>): tworzony jest nowy proces (będący duplikatem procesu głównego ale z pewnymi wyjątkami), którego przetwarzanie rozpoczyna się "w miejscu" wywołania <i>pcntl_fork()</i>, natomiast oryginalny proces kontynuuje dalej swoje działanie. W ten sposób uzyskaliśmy dwa egzemplarze naszego oryginalnego procesu rozróżniane na podstawie identyfikatora <i>PID</i> (nowy proces otrzymuje swój indywidualny PID). Wracając do naszego daemona, proces główny (<i>ang. parent</i>) odpowiedzialny będzie za przyjmowanie przychodzących połączeń, stworzenie nowego procesu (<i>ang. child</i>) i przekazanie obsługi połączenia do tego procesu. Dzięki temu każde połączenie z daemonem obsługiwane jest przez dedykowany proces a tym samym możliwa jest realizacja wielu zadań równolegle.</p> 

<code data-gist-id="63f76e0b61e0481e2059" data-gist-line="364, 370-410, 412" data-gist-highlight-line="372" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<p align="justify">Podejście takie wymusza obsługę komunikacji między procesami. Komunikacja międzyprocesowa realizowana będzie za pomocą, znanych z systemów <i>Unixowych</i>, <b>sygnałów</b> (<i>ang. signals</i>). Przykładowo, proces dziecko kończąc swoje działanie wysyła sygnał <i>SIGCHLD</i>, który dalej obsługiwany jest przez proces rodzica (główny) bądź proces główny kończąc swoje działanie wysyła <i>SIGTERM</i> do procesów dzieci (kończąc ich działanie).</p> 

<code data-gist-id="63f76e0b61e0481e2059" data-gist-line="150-182, 217-276" data-gist-highlight-line="177-180, 224, 245" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<p align="justify">Warto wzbogacić naszego daemona o obsługę <i>timeout'ów</i>, ponieważ możemy dość łatwo wyczerpać pulę dostępnych połączeń jeśli wszyscy klienci zaraz po podłączeniu do daemona zaprzestaną dalszej aktywności. Do obsługi timeout'ów również wykorzystane zostaną sygnały - <i>SIGALRM</i>.</p>

<code data-gist-id="63f76e0b61e0481e2059" data-gist-line="276, 281-289, 370-410, 412" data-gist-highlight-line="396-397" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<p align="justify">Aby zapobiec nadmiernemu obciążeniu naszego systemu (poprzez niekontrolowane forkowanie procesów) bądź sytuacji znanej jako <a href="http://en.wikipedia.org/wiki/Fork_bomb" target="_blank"><i>fork bomb</i></a>, konieczne jest zarządzanie pulą dostępnych połączeń. Odpowiedzialny za to będzie proces główny, który przechowuje listę aktywnych połączeń. W przypadku przekroczenia dopuszczalnej liczby połączeń, wstrzymuje przyjmowanie nowych połączeń do czasu zwolnienia puli.</p>

<p>Ostatnim elementem układanki jest zapewnienie komunikacji na linii klient-serwer. Wykorzystane zostaną tutaj <b>sockety</b> (<i>ang. sockets</i>).</p> 

<code data-gist-id="63f76e0b61e0481e2059" data-gist-line="296, 300-308, 312-347" data-gist-highlight-line="302-305, 327, 332" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>  

<p align="justify">Daemon, z definicji, jest procesem działającym w tle (<i>ang. background</i>) oraz dodatkowo raz uruchomiony powinien działać zawsze - stąd w powyższym fragmencie kodu warunek <i>while(true)</i>. Dodatkowo dobrze zaimplementowany daemon powinien zapobiegać uruchomieniu wielu instancji w danym środowisku (np. poprzez <i>locks</i>) czy też nie powinien wyświetlać komunikatów na <i>STDOUT</i> (w powyższym przykładzie jedynie w celach diagnostycznych). W omawianym tutaj przykładzie przedstawione zostały jedynie podstawowe mechanizmy umożliwiające implementację daemona w PHP, ale pewne elementy nadal wymagają pracy, np. obsługa błędów czy też proces nadrzędny restartujący daemona w przypadku błędu. Tym samym zachęcam do korzystania z mojego przykładu i dostosowania go do Waszych potrzeb.</p>

<p>Kompletny kod znajdziecie <a href="https://gist.github.com/thejoyboy/63f76e0b61e0481e2059" target="_blank">tutaj</a>.</p>   

<p>Przydatne linki:<br />
<ul>
<li><a href="http://kvz.io/blog/2009/01/09/create-daemons-in-php/" target="_blank">http://kvz.io/blog/2009/01/09/create-daemons-in-php/</a></li>
<li><a href="http://collaboradev.com/2011/03/31/php-daemons-tutorial/" target="_blank">http://collaboradev.com/2011/03/31/php-daemons-tutorial/</a></li>
<li><a href="http://community.spiceworks.com/topic/500944-is-using-php-as-a-daemon-a-good-idea" target="_blank">http://community.spiceworks.com/topic/500944-is-using-php-as-a-daemon-a-good-idea</a></li>
<li><a href="http://devzone.zend.com/209/writing-socket-servers-in-php/" target="_blank">http://devzone.zend.com/209/writing-socket-servers-in-php/</a></li>
<li><a href="http://www.devshed.com/c/a/PHP/Socket-Programming-With-PHP/" target="_blank">http://www.devshed.com/c/a/PHP/Socket-Programming-With-PHP/</a></li>
<li><a href="http://michaelcamden.me/?p=36" target="_blank">http://michaelcamden.me/?p=36</a></li>
<li><a href="http://www.binarytides.com/php-socket-programming-tutorial/" target="_blank">http://www.binarytides.com/php-socket-programming-tutorial/</a></li>
<li><a href="http://www.mullie.eu/parallel-processing-multi-tasking-php/" target="_blank">http://www.mullie.eu/parallel-processing-multi-tasking-php/</a></li>
<li><a href="http://code.hootsuite.com/parallel-processing-task-distribution-with-php/" target="_blank">http://code.hootsuite.com/parallel-processing-task-distribution-with-php/</a></li>
<li><a href="http://www.workingsoftware.com.au/page/Something_Like_Threading" target="_blank">http://www.workingsoftware.com.au/page/Something_Like_Threading</a></li>
<li><a href="http://www.tuxradar.com/practicalphp/16/1/4" target="_blank">http://www.tuxradar.com/practicalphp/16/1/4</a></li>
<li><a href="http://pleac.sourceforge.net/pleac_php/processmanagementetc.html" target="_blank">http://pleac.sourceforge.net/pleac_php/processmanagementetc.html</a></li>
<li><a href="http://www.tuxradar.com/practicalphp/16/0/0" target="_blank">http://www.tuxradar.com/practicalphp/16/0/0</a></li>
<li><a href="https://www.sharcnet.ca/help/index.php/Signal_Handling_and_Checkpointing" target="_blank">https://www.sharcnet.ca/help/index.php/Signal_Handling_and_Checkpointing</a></li>
<li><a href="http://www.devshed.com/c/a/php/managing-standalone-scripts-in-php/" target="_blank">http://www.devshed.com/c/a/php/managing-standalone-scripts-in-php/</a></li>
<li><a href="http://sysmagazine.com/posts/179075/" target="_blank">http://sysmagazine.com/posts/179075/</a></li>
<li><a href="https://github.com/kakserpom/phpdaemon" target="_blank">https://github.com/kakserpom/phpdaemon</a></li>
<li><a href="https://github.com/shaneharter/PHP-Daemon" target="_blank">https://github.com/shaneharter/PHP-Daemon</a></li>
<li><a href="https://github.com/lukaszkujawa/php-multithreaded-socket-server" target="_blank">https://github.com/lukaszkujawa/php-multithreaded-socket-server</a></li>
<li><a href="https://leanpub.com/php/" target="_blank">https://leanpub.com/php/</a></li>
</ul>
</p>

