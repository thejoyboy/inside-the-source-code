<p>Rozwiązanie przedstawione w jednym z poprzednich <a href="http://inside-the-source-code.blogspot.com/2014/08/php-deamons-czesc-i.html" target="_blank">artykułów</a> pozwala na realizację daemona w PHP dzięki wykorzystaniu mechanizmu <i>forkowania</i> procesów. Niestety podatne jest na powstawanie tzw. <i><b>procesów zombie</b></i> - proces dziecko staje się procesem zombie dopóki proces główny nie obsłuży jego statusu wyjścia (ang. <i>exit code</i>) bądź sam (proces główny) nie zakończy działania. W efekcie, przez procesy zombie, zajmowane są <i>sloty</i> w tablicy procesów (ang. <i>process table</i>) co w kontekście długiego działania daemona będzie stanowiło problem.</p>

<p>Omawiana powyżej implementacja daemona pozwala na powstawanie procesów zombie, ale również obsługuje takie procesy - w momencie nadejścia nowego połączenia z daemonem wszystkie procesy zombie oczekujące na obsługę tj. połączenia które zrealizowały swoje zadanie bądź zakończyły swoje działanie z powodu <i>timeoutu</i>, zostaną zakończone. Niestety, w okresach kiedy nie są obsługiwane żadne połączenia istnieje możliwość występowania dużej liczby procesów zombie. Rozwiązaniem tego problemu może być ignorowanie sygnałów <i><b>SIGCHLD</b></i> przez proces główny. Wówczas procesy dzieci będą umierały natychmiast, bez oczekiwania na obsługę statusu wyjścia przez proces rodzica.</p>

<code data-gist-id="454c3687785f186e8ab1" data-gist-line="149-185" data-gist-highlight-line="178" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<p>Jednym z wymagań stawianych procesowi głównemu jest kontrola liczby połączeń - chcemy zapobiegać nadmiernemu tworzeniu procesów w systemie. W poprzednim rozwiązaniu kontrolowane było to poprzez listę aktywnych procesów dzieci (oraz ich identyfikatorów <i>PID</i>). Możliwe było to dzięki obsłudze <i>SIGCHLD</i>, gdzie dokładnie wiedzieliśmy który proces kończy swoje działanie. Z kolei w omawianym tutaj rozwiązaniu, zapobiegającym powstawaniu procesów zombie, nie znamy identyfikatora procesu kończącego działanie, ponieważ nie obsługujemy <i>SIGCHLD</i>. Jednak funkcjonalność tą zrealizujemy w inny sposób - proces główny będzie kontrolował liczbę aktywnych procesów zwiększając ten licznik w momencie utworzenia nowego procesu do obsługi połączenia oraz zmniejszał go obsługując <i><b>SIGUSR2</b></i> (procesy dzieci umierając będą wysyłały ten sygnał do procesu głównego). Obsługa sygnałów <i>SIGUSR2</i> również będzie następowała w momencie nadejścia nowego połączenia, ale nie będzie to stanowiło problemu gdyż zanim zostanie utworzony nowy proces, licznik aktywnych procesów zostanie zaktualizowany, a tym samym będziemy wiedzieli czy możemy obsłużyć nowe połączenie.</p>

<code data-gist-id="454c3687785f186e8ab1" data-gist-line="149-156, 175-180, 184-185, 249-259, 290-305" data-gist-highlight-line="179, 301" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<p>Do rozwiązania pozostaje jeszcze jedna kwestia - proces główny umierając, powinien także ubijać aktywne procesy dzieci. Ponieważ nie przechowujemy listy identyfikatorów aktywnych procesów przez proces główny daemona, nie możemy ubijać poszczególnych procesów wysyłając <i>SIGINT</i> / <i>SIGTERM</i> do poszczególnych procesów dzieci. Zamiast tego, proces parenta umierając będzie wysyłał <i>SIGINT</i> / <i>SIGTERM</i> do wszystkich procesów o tym samym identyfikatorze grupy procesów co proces główny. Poszczególne procesy dzieci nie zostaną do końca odłączone od procesu rodzica (nie będą stawały się liderami sesji), a więc tym samym będą posiadały ten sam identyfikator grupy procesów.</p>

<code data-gist-id="454c3687785f186e8ab1" data-gist-line="212, 218-243" data-gist-highlight-line="228" data-gist-hide-footer="true" data-gist-hide-line-numbers="true"></code>

<p>Przedstawione powyżej rozwiązanie stanowi tylko jedno z możliwych rozwiązań problemów zombie. Zakres opisanych tutaj zmian jest niewielki
względem oryginalnego <a href="http://inside-the-source-code.blogspot.com/2014/08/php-deamons-czesc-i.html" target="_blank">rozwiązania</a>, a więc będzie prosty
do wprowadzenia. Docelowe rozwiązanie i tak będzie zależało od wymagań stawianemu Waszemu daemonowi, niemniej moje rozwiązanie może stanowić dobrą bazę do dalszych prac.</p>

<p>Kompletny kod znajdziecie <a href="https://gist.github.com/thejoyboy/454c3687785f186e8ab1" target="_blank">tutaj</a>.</p> 

<p>Przydatne linki:<br />
<ul>
<li><a href="http://en.wikipedia.org/wiki/Zombie_process" target="_blank">http://en.wikipedia.org/wiki/Zombie_process</a></li>
<li><a href="http://pleac.sourceforge.net/pleac_php/processmanagementetc.html" target="_blank">http://pleac.sourceforge.net/pleac_php/processmanagementetc.html</a></li>
<li><a href="http://php.net/manual/en/function.pcntl-fork.php" target="_blank">http://php.net/manual/en/function.pcntl-fork.php</a></li>
<li><a href="http://fixunix.com/unix/533215-how-avoid-zombie-processes.html" target="_blank">http://fixunix.com/unix/533215-how-avoid-zombie-processes.html</a></li>
<li><a href="http://stackoverflow.com/questions/9976441/terminating-zombie-child-processes-forked-from-socket-server" target="_blank">http://stackoverflow.com/questions/9976441/terminating-zombie-child-processes-forked-from-socket-server</a></li>
<li><a href="http://stackoverflow.com/questions/16238510/pcntl-fork-results-in-defunct-parent-process" target="_blank">http://stackoverflow.com/questions/16238510/pcntl-fork-results-in-defunct-parent-process</a></li>
<li><a href="http://unix.stackexchange.com/questions/11172/how-can-i-kill-a-defunct-process-whose-parent-is-init" target="_blank">http://unix.stackexchange.com/questions/11172/how-can-i-kill-a-defunct-process-whose-parent-is-init</a></li>
<li><a href="http://lubutu.com/code/spawning-in-unix" target="_blank">http://lubutu.com/code/spawning-in-unix</a></li>
</ul></p>
 

